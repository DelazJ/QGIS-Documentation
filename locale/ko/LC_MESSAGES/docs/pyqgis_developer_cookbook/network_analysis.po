# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2002-now, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
# 
# Translators:
# Harrissou Sant-anna, 2024
# Kwon.Yongchan <ruvyn@naver.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation 3.34\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-15 11:22+0000\n"
"PO-Revision-Date: 2024-03-02 11:58+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>, 2024\n"
"Language-Team: Korean (https://app.transifex.com/qgis/teams/6144/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../<rst_prolog>:5
msgid ""
"Translation is a community effort :ref:`you can join "
"<translation_guidelines>`. This page is currently translated at |translation"
" progress|."
msgstr ""
"번역은 :ref:`여러분이 참여할 수 있는 <translation_guidelines>` 커뮤니티 활동입니다. 이 페이지는 현재 "
"|translation progress| 번역되었습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:18
msgid "Network analysis library"
msgstr "네트워크 분석 라이브러리"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:20
msgid ""
"The code snippets on this page need the following imports if you're outside "
"the pyqgis console:"
msgstr "PyQGIS 콘솔을 사용하지 않는 경우 이 페이지에 있는 코드 조각들을 다음과 같이 가져와야 합니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:34
msgid "The network analysis library can be used to:"
msgstr "네트워크 분석 라이브러리는 다음에 사용할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:36
msgid ""
"create mathematical graph from geographical data (polyline vector layers)"
msgstr "지리 데이터(폴리라인 벡터 레이어)로부터 수학적인 그래프를 생성할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:37
msgid ""
"implement basic methods from graph theory (currently only Dijkstra's "
"algorithm)"
msgstr "그래프 이론으로부터 기본 메소드들을 (현재로서는 데이크스트라(Dijkstra) 알고리즘만) 구현할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:40
msgid ""
"The network analysis library was created by exporting basic functions from "
"the RoadGraph core plugin and now you can use it's methods in plugins or "
"directly from the Python console."
msgstr ""
"RoadGraph 핵심 플러그인에서 기본 함수들을 내보내서 네트워크 분석 알고리즘을 생성했습니다. 이제 플러그인에서 또는 파이썬 콘솔에서"
" 직접 이 라이브러리의 메소드들을 사용할 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:45
msgid "General information"
msgstr "일반 정보"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:47
msgid "Briefly, a typical use case can be described as:"
msgstr "이 라이브러리의 전형적인 용도를 간단히 설명하면 다음과 같습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:49
msgid "create graph from geodata (usually polyline vector layer)"
msgstr "지리 데이터(일반적으로 폴리라인 벡터 레이어)로부터 그래프 생성"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:50
msgid "run graph analysis"
msgstr "그래프 분석 실행"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:51
msgid "use analysis results (for example, visualize them)"
msgstr "분석 결과 이용 (예를 들어 분석 결과의 시각화 등)"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:54
msgid "Building a graph"
msgstr "그래프 작성하기"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:56
msgid ""
"The first thing you need to do --- is to prepare input data, that is to "
"convert a vector layer into a graph. All further actions will use this "
"graph, not the layer."
msgstr ""
"가장 먼저 해야 할 일은 입력 데이터를 준비하는, 다시 말해 벡터 레이어를 그래프로 변환하는 것입니다. 이후의 모든 작업은 레이어가 "
"아니라 이 그래프를 사용할 것입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:60
msgid ""
"As a source we can use any polyline vector layer. Nodes of the polylines "
"become graph vertexes, and segments of the polylines are graph edges. If "
"several nodes have the same coordinates then they are the same graph vertex."
" So two lines that have a common node become connected to each other."
msgstr ""
"어떤 폴리라인 벡터 레이어라도 소스로 사용할 수 있습니다. 폴리라인의 노드(node)는 그래프의 꼭짓점(vertex)이 되고, 폴리라인의"
" 선분(segment)은 그래프의 변(edge)이 됩니다. 노드 몇 개가 동일한 좌표에 있을 경우 그 노드들은 동일한 그래프 꼭짓점이 "
"됩니다. 따라서 공통 노드를 가진 2개의 선분은 서로 연결됩니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:65
msgid ""
"Additionally, during graph creation it is possible to \"fix\" (\"tie\") to "
"the input vector layer any number of additional points. For each additional "
"point a match will be found --- the closest graph vertex or closest graph "
"edge. In the latter case the edge will be split and a new vertex added."
msgstr ""
"또, 그래프를 생성하는 도중에 입력 벡터 레이어에 추가적인 포인트를 몇 개라도 \"고정(fix)\"(다른 용어로는 "
"\"결속(tie)\")시킬 수 있습니다. 각 추가 포인트에 대응하는, 가장 가까운 그래프 꼭짓점 또는 가장 가까운 그래프 변을 찾을 "
"것입니다. 후자의 경우 변을 분할해서 새 꼭짓점을 추가합니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:70
msgid ""
"Vector layer attributes and length of an edge can be used as the properties "
"of an edge."
msgstr "벡터 레이어의 속성과 변 길이를 그래프 변의 속성으로 쓸 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:73
msgid ""
"Converting from a vector layer to the graph is done using the `Builder "
"<https://en.wikipedia.org/wiki/Builder_pattern>`_ programming pattern. A "
"graph is constructed using a so-called Director. There is only one Director "
"for now: :class:`QgsVectorLayerDirector "
"<qgis.analysis.QgsVectorLayerDirector>`. The director sets the basic "
"settings that will be used to construct a graph from a line vector layer, "
"used by the builder to create the graph. Currently, as in the case with the "
"director, only one builder exists: :class:`QgsGraphBuilder "
"<qgis.analysis.QgsGraphBuilder>`, that creates :class:`QgsGraph "
"<qgis.analysis.QgsGraph>` objects. You may want to implement your own "
"builders that will build a graph compatible with such libraries as `BGL "
"<https://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ or "
"`NetworkX <https://networkx.org/>`_."
msgstr ""
"`빌더 <https://ko.wikipedia.org/wiki/%EB%B9%8C%EB%8D%94_%ED%8C%A8%ED%84%B4>`_ "
"프로그래밍 패턴을 사용해서 벡터 레이어를 그래프로 변환합니다. 소위 말하는 디렉터(Director)를 사용해서 그래프를 작성합니다. 현재"
" 디렉터는 :class:`QgsVectorLayerDirector <qgis.analysis.QgsVectorLayerDirector>`"
" 클래스 하나뿐입니다. 디렉터는 라인 벡터 레이어로부터 그래프를 작성하는 데 쓰일 기본 설정을 설정하는데, 빌더가 이를 사용해서 그래프를"
" 생성합니다. 현재 존재하는 빌더는 디렉터의 경우와 마찬가지로 :class:`QgsGraph "
"<qgis.analysis.QgsGraph>` 클래스 객체를 생성하는 :class:`QgsGraphBuilder "
"<qgis.analysis.QgsGraphBuilder>` 클래스 하나뿐입니다. 여러분은 `BGL "
"<https://www.boost.org/doc/libs/1_48_0/libs/graph/doc/index.html>`_ 또는 "
"`NetworkX <https://networkx.org/>`_ 같은 라이브러리와 호환되는 그래프를 작성하는 사용자 정의 빌더를 "
"구현하기를 원할 수도 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:86
msgid ""
"To calculate edge properties the programming pattern `strategy "
"<https://en.wikipedia.org/wiki/Strategy_pattern>`_ is used. For now only "
":class:`QgsNetworkDistanceStrategy "
"<qgis.analysis.QgsNetworkDistanceStrategy>` strategy (that takes into "
"account the length of the route) and :class:`QgsNetworkSpeedStrategy "
"<qgis.analysis.QgsNetworkSpeedStrategy>` (that also considers the speed) are"
" availabile. You can implement your own strategy that will use all necessary"
" parameters. For example, RoadGraph plugin uses a strategy that computes "
"travel time using edge length and speed value from attributes."
msgstr ""
"변(edge) 속성을 계산하기 위해서는 `전략(strategy) "
"<https://ko.wikipedia.org/wiki/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4>`_ "
"프로그래밍 패턴을 사용합니다. 현재로서는 (경로(route)의 길이를 연산에 넣는) "
":class:`QgsNetworkDistanceStrategy "
"<qgis.analysis.QgsNetworkDistanceStrategy>` 전략과 (속도도 연산에 넣는) "
":class:`QgsNetworkSpeedStrategy <qgis.analysis.QgsNetworkSpeedStrategy>` 전략만"
" 사용할 수 있습니다. 필요한 모든 파라미터를 사용하는 사용자 정의 전략을 구현할 수도 있습니다. 예를 들어 RoadGraph 플러그인은"
" 속성으로부터 변 길이와 속도 값을 사용해서 이동 시간을 계산하는 전략을 사용합니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:95
msgid "It's time to dive into the process."
msgstr "이제 실제로 해봅시다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:97
msgid "First of all, to use this library we should import the analysis module"
msgstr "가장 먼저, 이 라이브러리를 사용하려면 분석 모듈을 가져와야 합니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:103
msgid "Then some examples for creating a director"
msgstr "다음은 디렉터를 생성하는 몇 가지 방법의 예시입니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:119
msgid ""
"To construct a director, we should pass a vector layer that will be used as "
"the source for the graph structure and information about allowed movement on"
" each road segment (one-way or bidirectional movement, direct or reverse "
"direction). The call looks like this"
msgstr ""
"디렉터를 작성하려면, 그래프 구조 및 각 도로 선분 상에서 허용되는 (일방통행인지 양방향인지, 순방향인지 역방향인지) 움직임에 대한 "
"정보의 소스로 사용할 벡터 레이어를 전달해야 합니다. 이 호출은 다음처럼 보일 것입니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:133
msgid "And here is full list of what these parameters mean:"
msgstr "각 파라미터가 의미하는 바는 다음과 같습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:135
msgid "``vectorLayer`` --- vector layer used to build the graph"
msgstr "``vectorLayer`` --- 그래프를 작성하기 위해 사용하는 벡터 레이어"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:136
msgid ""
"``directionFieldId`` --- index of the attribute table field, where "
"information about roads direction is stored. If ``-1``, then don't use this "
"info at all. An integer."
msgstr ""
"``directionFieldId`` --- 도로 방향에 관한 정보가 저장된 속성 테이블 필드의 인덱스. 값이 ``-1`` 일 경우 방향"
" 정보를 전혀 사용하지 않습니다. 정수형입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:139
msgid ""
"``directDirectionValue`` --- field value for roads with direct direction "
"(moving from first line point to last one). A string."
msgstr ""
"``directDirectionValue`` --- 순방향 (라인의 첫 번째 포인트에서 마지막 포인트로 이동하는) 도로의 필드 값. "
"문자열입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:141
msgid ""
"``reverseDirectionValue`` --- field value for roads with reverse direction "
"(moving from last line point to first one). A string."
msgstr ""
"``reverseDirectionValue`` --- 역방향 (라인의 마지막 포인트에서 첫 번째 포인트로 이동하는) 도로의 필드 값. "
"문자열입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:143
msgid ""
"``bothDirectionValue`` --- field value for bidirectional roads (for such "
"roads we can move from first point to last and from last to first). A "
"string."
msgstr ""
"``bothDirectionValue`` --- 양방향 (첫 번째 포인트에서 마지막으로도 마지막에서 첫 번째로도 이동할 수 있는) 도로의"
" 필드 값. 문자열입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:145
msgid ""
"``defaultDirection`` --- default road direction. This value will be used for"
" those roads where field ``directionFieldId`` is not set or has some value "
"different from any of the three values specified above. Possible values are:"
msgstr ""
"``defaultDirection`` --- 기본 도로 방향. ``directionFieldId`` 필드가 설정되지 않은 도로 또는 "
"앞에서 설명한 값 3개 가운데 어떤 값과도 다른 값을 가진 도로에 이 값이 쓰일 것입니다. 다음 값들을 사용할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:149
msgid ""
":attr:`QgsVectorLayerDirector.DirectionForward "
"<qgis.analysis.QgsVectorLayerDirector.DirectionForward>` --- One-way direct"
msgstr ""
":attr:`QgsVectorLayerDirector.DirectionForward "
"<qgis.analysis.QgsVectorLayerDirector.DirectionForward>` --- 순방향 일방통행"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:150
msgid ""
":attr:`QgsVectorLayerDirector.DirectionBackward "
"<qgis.analysis.QgsVectorLayerDirector.DirectionBackward>` --- One-way "
"reverse"
msgstr ""
":attr:`QgsVectorLayerDirector.DirectionBackward "
"<qgis.analysis.QgsVectorLayerDirector.DirectionBackward>` --- 역방향 일방통행"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:151
msgid ""
":attr:`QgsVectorLayerDirector.DirectionBoth "
"<qgis.analysis.QgsVectorLayerDirector.DirectionBoth>` --- Two-way"
msgstr ""
":attr:`QgsVectorLayerDirector.DirectionBoth "
"<qgis.analysis.QgsVectorLayerDirector.DirectionBoth>` --- 양방향"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:154
msgid ""
"It is necessary then to create a strategy for calculating edge properties"
msgstr "그 다음 변의 속성을 계산하기 위한 전략을 생성해야 합니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:166
msgid "And tell the director about this strategy"
msgstr "그리고 디렉터에 이 전략을 알려줍니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:173
msgid ""
"Now we can use the builder, which will create the graph. The "
":class:`QgsGraphBuilder <qgis.analysis.QgsGraphBuilder>` class constructor "
"takes several arguments:"
msgstr ""
"이제 그래프를 생성할 빌더를 사용할 수 있습니다. :class:`QgsGraphBuilder "
"<qgis.analysis.QgsGraphBuilder>` 클래스 작성자(constructor)는 인자 몇 개를 받습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:176
msgid "``crs`` --- coordinate reference system to use. Mandatory argument."
msgstr "``crs`` --- 사용할 좌표계. 필수 인자입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:177
msgid ""
"``otfEnabled`` --- use \"on the fly\" reprojection or no. By default "
":const:`True` (use OTF)."
msgstr ""
"``otfEnabled`` --- \"실시간(on-the-fly)\" 재투영을 사용할지 여부. 기본값은 :const:`True` (OTF"
" 사용)입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:179
msgid "``topologyTolerance`` --- topological tolerance. Default value is 0."
msgstr "``topologyTolerance`` --- 위상 허용 오차. 기본값은 0입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:180
msgid "``ellipsoidID`` --- ellipsoid to use. By default \"WGS84\"."
msgstr "``ellipsoidID`` --- 사용할 타원체. 기본값은 \"WGS84\"입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:187
msgid ""
"Also we can define several points, which will be used in the analysis. For "
"example"
msgstr "또 분석 작업에 사용할 포인트 몇 개를 다음과 같이 정의할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:195
msgid ""
"Now all is in place so we can build the graph and \"tie\" these points to it"
msgstr "이제 모든 준비가 끝났기 때문에, 그래프를 작성하고 이 포인트들을 그래프에 \"결속(tie)\"시킬 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:201
msgid ""
"Building the graph can take some time (which depends on the number of "
"features in a layer and layer size). ``tiedPoints`` is a list with "
"coordinates of \"tied\" points. When the build operation is finished we can "
"get the graph and use it for the analysis"
msgstr ""
"그래프를 만드는 데 시간이 좀 걸릴 수도 있습니다. (레이어에 있는 피처의 개수 및 레이어 크기에 따라 다릅니다.) "
"``tiedPoints`` 는 \"결속\"된 포인트들의 좌표 목록입니다. 빌더의 작업이 완료되면 분석에 사용할 수 있는 그래프를 얻게 "
"됩니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:210
msgid "With the next code we can get the vertex indexes of our points"
msgstr "다음 코드를 사용하면 포인트들의 꼭짓점 인덱스들을 얻을 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:219
msgid "Graph analysis"
msgstr "그래프 분석"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:221
msgid ""
"Networks analysis is used to find answers to two questions: which vertexes "
"are connected and how to find a shortest path. To solve these problems the "
"network analysis library provides Dijkstra's algorithm."
msgstr ""
"네트워크 분석은 다음 두 가지 질문에 대한 답을 찾는 데 사용됩니다. 어떤 꼭짓점들이 연결되어 있는가? 그리고 어떻게 최단 경로를 찾을 "
"것인가? 네트워크 분석 라이브러리는 이 문제를 해결하기 위해 데이크스트라 알고리즘(Dijkstra's algorithm)을 제공합니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:225
msgid ""
"Dijkstra's algorithm finds the shortest route from one of the vertexes of "
"the graph to all the others and the values of the optimization parameters. "
"The results can be represented as a shortest path tree."
msgstr ""
"데이크스트라 알고리즘은 그래프의 한 꼭짓점에서 다른 모든 꼭짓점으로 가는 최단 경로와 최적화 파라미터의 값을 찾습니다. 그 결과는 최단 "
"경로 트리로 나타낼 수 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:229
msgid ""
"The shortest path tree is a directed weighted graph (or more precisely a "
"tree) with the following properties:"
msgstr "최단 경로 트리는 다음 속성들을 가진 방향성 가중치 그래프(더 정확하게는 트리)입니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:232
msgid "only one vertex has no incoming edges — the root of the tree"
msgstr "들어오는 변이 없는 꼭짓점은 단 하나, 트리의 루트(root)뿐입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:233
msgid "all other vertexes have only one incoming edge"
msgstr "다른 모든 꼭짓점은 들어오는 변을 딱 하나 가지고 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:234
msgid ""
"if vertex B is reachable from vertex A, then the path from A to B is the "
"single available path and it is optimal (shortest) on this graph"
msgstr ""
"꼭짓점 A에서 꼭짓점 B에 도달할 수 있다면, A에서 B로의 경로는 사용할 수 있는 단 하나의 경로이며 이 그래프 상에서 최적(최단) "
"경로입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:237
msgid ""
"To get the shortest path tree use the methods :meth:`shortestTree() "
"<qgis.analysis.QgsGraphAnalyzer.shortestTree>` and :meth:`dijkstra() "
"<qgis.analysis.QgsGraphAnalyzer.dijkstra>` of the :class:`QgsGraphAnalyzer "
"<qgis.analysis.QgsGraphAnalyzer>` class. It is recommended to use the "
":meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` method because "
"it works faster and uses memory more efficiently."
msgstr ""
"최단 경로 트리를 생성하려면 :class:`QgsGraphAnalyzer <qgis.analysis.QgsGraphAnalyzer>` "
"클래스의 :meth:`shortestTree() <qgis.analysis.QgsGraphAnalyzer.shortestTree>` 와 "
":meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` 메소드를 사용하십시오. "
":meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` 메소드를 사용할 것을 "
"권장합니다. 더 빠르고 메모리를 더 효율적으로 사용하기 때문입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:244
msgid ""
"The :meth:`shortestTree() <qgis.analysis.QgsGraphAnalyzer.shortestTree>` "
"method is useful when you want to walk around the shortest path tree. It "
"always creates a new graph object (QgsGraph) and accepts three variables:"
msgstr ""
"여러분이 최단 경로 트리를 탐색하고 싶은 경우 :meth:`shortestTree() "
"<qgis.analysis.QgsGraphAnalyzer.shortestTree>` 메소드가 유용합니다. 이 메소드는 언제나 새 그래프 "
"객체(:class:`QgsGraph <qgis.analysis.QgsGraph>` 클래스)를 생성하며 다음 변수 3개를 받습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:249
msgid "``source`` --- input graph"
msgstr "``source`` --- 입력 그래프"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:250
msgid ""
"``startVertexIdx`` --- index of the point on the tree (the root of the tree)"
msgstr "``startVertexIdx`` --- 트리 상에 있는 포인트의 인덱스 (트리의 루트)"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:251
msgid "``criterionNum`` --- number of edge property to use (started from 0)."
msgstr "``criterionNum`` --- 사용할 변 속성의 번호 (0에서 시작)"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:257
msgid ""
"The :meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` method has "
"the same arguments, but returns two arrays. In the first array element `n` "
"contains index of the incoming edge or -1 if there are no incoming edges. In"
" the second array element `n` contains the distance from the root of the "
"tree to vertex `n` or DOUBLE_MAX if vertex `n` is unreachable from the root."
msgstr ""
":meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` 메소드도 동일한 인자를 "
"받지만, 2개의 배열을 반환합니다. 첫 번째 배열 요소 ``n`` 은 들어오는 변의 인덱스를 또는 들어오는 변이 없는 경우 -1을 "
"담습니다. 두 번째 배열 요소 ``n`` 은 트리의 루트에서 ``n`` 꼭짓점까지의 거리를 또는 루트에서 ``n`` 꼭짓점에 도달할 수 "
"없는 경우 DOUBLE_MAX를 담습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:268
msgid ""
"Here is some very simple code to display the shortest path tree using the "
"graph created with the :meth:`shortestTree() "
"<qgis.analysis.QgsGraphAnalyzer.shortestTree>` method (select linestring "
"layer in :guilabel:`Layers` panel and replace coordinates with your own)."
msgstr ""
"다음은 :meth:`shortestTree() <qgis.analysis.QgsGraphAnalyzer.shortestTree>` "
"메소드로 생성한 그래프를 사용해서 최단 경로 트리를 표시하는 매우 단순한 코드입니다. (:guilabel:`Layers` 패널에서 "
"라인스트링 레이어를 선택한 다음 좌표를 여러분 자신의 좌표로 대체하십시오.)"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:273
msgid ""
"Use this code only as an example, it creates a lot of :class:`QgsRubberBand "
"<qgis.gui.QgsRubberBand>` objects and may be slow on large datasets."
msgstr ""
"이 코드를 예제로써만 사용하십시오. 이 코드는 :class:`QgsRubberBand <qgis.gui.QgsRubberBand>` "
"클래스 객체를 많이 생성하기 때문에 대용량 데이터셋의 경우 느려질 수도 있습니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:309
msgid ""
"Same thing but using the :meth:`dijkstra() "
"<qgis.analysis.QgsGraphAnalyzer.dijkstra>` method"
msgstr ""
"동일한 목적이지만 :meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` 메소드를 "
"사용하는 코드입니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:346
msgid "Finding shortest paths"
msgstr "최단 경로 찾기"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:348
msgid ""
"To find the optimal path between two points the following approach is used. "
"Both points (start A and end B) are \"tied\" to the graph when it is built. "
"Then using the :meth:`shortestTree() "
"<qgis.analysis.QgsGraphAnalyzer.shortestTree>` or :meth:`dijkstra() "
"<qgis.analysis.QgsGraphAnalyzer.dijkstra>` method we build the shortest path"
" tree with root in the start point A. In the same tree we also find the end "
"point B and start to walk through the tree from point B to point A. The "
"whole algorithm can be written as:"
msgstr ""
"두 포인트 사이의 최적 경로를 찾기 위해 다음 접근법을 사용합니다. 두 포인트 (시작 포인트 A와 종단 포인트 B) 모두 작성 시 "
"그래프에 \"결속\"됩니다. 그 다음 :meth:`shortestTree() "
"<qgis.analysis.QgsGraphAnalyzer.shortestTree>` 또는 :meth:`dijkstra() "
"<qgis.analysis.QgsGraphAnalyzer.dijkstra>` 메소드를 사용해서 트리의 루트가 시작 포인트 A인 최단 경로"
" 트리를 생성합니다. 이 트리에서 종단 포인트 B를 찾아, 트리 안에서 B에서 A로 가는 경로를 탐색합니다. 이 전체 알고리즘을 다음처럼"
" 작성할 수 있습니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:366
msgid ""
"At this point we have the path, in the form of the inverted list of vertexes"
" (vertexes are listed in reversed order from end point to start point) that "
"will be visited during traveling by this path."
msgstr ""
"이 시점에서 이 경로를 지나가는 동안 거치게 될 꼭짓점들의 역순 목록의 형태로 경로를 얻게 됩니다. (꼭짓점들이 종단 포인트에서 시작 "
"포인트 순서로 역순으로 나열됩니다.)"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:370
msgid ""
"Here is the sample code for QGIS Python Console (you may need to load and "
"select a linestring layer in TOC and replace coordinates in the code with "
"yours) that uses the :meth:`shortestTree() "
"<qgis.analysis.QgsGraphAnalyzer.shortestTree>` method"
msgstr ""
"다음은 :meth:`shortestTree() <qgis.analysis.QgsGraphAnalyzer.shortestTree>` "
"메소드를 사용하는 QGIS 파이썬 콘솔의 예시 코드입니다 (TOC(Table of Contents)에 라인스트링 레이어를 불러와 선택한 "
"다음 코드에 있는 좌표를 여러분의 좌표로 대체해야 할 수도 있습니다):"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:426
msgid ""
"And here is the same sample but using the :meth:`dijkstra() "
"<qgis.analysis.QgsGraphAnalyzer.dijkstra>` method"
msgstr ""
"다음은 동일한 예시이지만 :meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` "
"메소드를 사용하는 코드입니다:"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:482
msgid "Areas of availability"
msgstr "도달 가능 영역"

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:484
msgid ""
"The area of availability for vertex A is the subset of graph vertexes that "
"are accessible from vertex A and the cost of the paths from A to these "
"vertexes are not greater that some value."
msgstr ""
"꼭짓점 A의 도달 가능 영역(area of availability)이란 꼭짓점 A에서 접근할 수 있고, 꼭짓점 A에서 이 꼭짓점들까지의 "
"경로 비용이 지정된 값을 초과하지 않는, 그래프 꼭짓점들의 부분집합을 말합니다. "

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:488
msgid ""
"More clearly this can be shown with the following example: \"There is a fire"
" station. Which parts of city can a fire truck reach in 5 minutes? 10 "
"minutes? 15 minutes?\". Answers to these questions are fire station's areas "
"of availability."
msgstr ""
"다음 질문을 통해 이를 더 명확히 알 수 있습니다. \"소방서가 있다. 소방차가 5분/10분/15분 안에 도착할 수 있는 도시의 구역은 "
"어디인가?\" 이 질문에 대한 답이 바로 소방서의 도달 가능 영역입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:493
msgid ""
"To find the areas of availability we can use the :meth:`dijkstra() "
"<qgis.analysis.QgsGraphAnalyzer.dijkstra>` method of the "
":class:`QgsGraphAnalyzer <qgis.analysis.QgsGraphAnalyzer>` class. It is "
"enough to compare the elements of the cost array with a predefined value. If"
" cost[i] is less than or equal to a predefined value, then vertex i is "
"inside the area of availability, otherwise it is outside."
msgstr ""
"도달 가능 영역을 찾으려면 :class:`QgsGraphAnalyzer <qgis.analysis.QgsGraphAnalyzer>` "
"클래스의 :meth:`dijkstra() <qgis.analysis.QgsGraphAnalyzer.dijkstra>` 메소드를 사용하면 "
"됩니다. 비용 배열의 요소들을 사전 정의된 값과 비교하는 것으로 충분합니다. cost[i]가 사전 정의 값 이하인 경우, 꼭짓점 i는 "
"도달 가능 영역 안에 있는 것이고, 초과하는 경우 밖에 있는 것입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:500
msgid ""
"A more difficult problem is to get the borders of the area of availability. "
"The bottom border is the set of vertexes that are still accessible, and the "
"top border is the set of vertexes that are not accessible. In fact this is "
"simple: it is the availability border based on the edges of the shortest "
"path tree for which the source vertex of the edge is accessible and the "
"target vertex of the edge is not."
msgstr ""
"도달 가능 영역의 경계를 구하는 일은 좀 더 어려운 문제입니다. 하단 경계는 도달 가능한 꼭짓점들의 집합이고, 상단 경계는 도달 불가능한"
" 꼭짓점들의 집합입니다. 사실 단순합니다 --- 변의 소스 꼭짓점에 접근할 수 있고 변의 대상 꼭짓점에는 접근할 수 없는 최단 경로 "
"트리의 변들을 바탕으로 한 도달 가능 경계입니다."

#: ../../docs/pyqgis_developer_cookbook/network_analysis.rst:507
msgid "Here is an example"
msgstr "다음은 그 예시입니다:"
