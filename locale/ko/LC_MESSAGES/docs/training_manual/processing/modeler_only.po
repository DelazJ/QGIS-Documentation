# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2002-now, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
# 
# Translators:
# Harrissou Sant-anna, 2024
# Kwon.Yongchan <ruvyn@naver.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation 3.34\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-15 11:22+0000\n"
"PO-Revision-Date: 2024-03-02 11:58+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>, 2024\n"
"Language-Team: Korean (https://app.transifex.com/qgis/teams/6144/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../<rst_prolog>:5
msgid ""
"Translation is a community effort :ref:`you can join "
"<translation_guidelines>`. This page is currently translated at |translation"
" progress|."
msgstr ""
"번역은 :ref:`여러분이 참여할 수 있는 <translation_guidelines>` 커뮤니티 활동입니다. 이 페이지는 현재 "
"|translation progress| 번역되었습니다."

#: ../../docs/training_manual/processing/modeler_only.rst:2
msgid "Using modeler-only tools for creating a model"
msgstr "모델을 생성하기 위해 모델 설계자 전용 도구 사용하기"

#: ../../docs/training_manual/processing/modeler_only.rst:4
msgid ""
"This lesson shows how to use some algorithms that are only available in the "
"modeler, to provide additional functionality to models."
msgstr ""
"이 수업에서는 모델 설계자에서만 사용할 수 있는 몇몇 알고리즘을 사용해서 어떻게 모델에 추가 기능을 제공할 수 있는지 알려줄 것입니다."

#: ../../docs/training_manual/processing/modeler_only.rst:6
msgid ""
"The goal of this lesson is to use the modeler to create an interpolation "
"algorithm that takes into account the current selection, not just to use "
"only selected features, but to use the extent of that selection to create "
"the interpolated raster layer."
msgstr ""
"이 수업의 목표는 모델 설계자를 사용해서 보간된 래스터 레이어를 생성하기 위해 현재 선택 집합을 입력받아 선택한 피처들만이 아니라 해당 "
"선택 집합의 영역을 사용하는 보간 알고리즘을 생성하는 것입니다."

#: ../../docs/training_manual/processing/modeler_only.rst:8
msgid ""
"The interpolation process involves two steps, as it has been already "
"explained in previous lessons: rasterizing the points layer and fill the no-"
"data values that appear in the rasterized layer. In case the points layer "
"has a selection, only selected points will be used, but if the output extent"
" is set to be automatically adjusted, the full extent of the layer will be "
"used. That is, the extent of the layer is always considered to be the full "
"extent of all features, not the one computed from just the selected ones. We"
" will try to fix that by using some additional tools into our model."
msgstr ""
"보간 처리 과정은 이전 수업들에서 설명한 대로 두 단계로 이루어집니다 --- 포인트 레이어를 래스터화한 다음 래스터화된 레이어에 나타나는"
" NODATA 값을 채우는 것이죠. 포인트 레이어에 선택 집합이 있는 경우 선택된 포인트만 사용할 것이지만, 산출 범위를 자동 조정되도록"
" 설정했다면 레이어 전체 영역을 사용할 것입니다. 즉 레이어 영역은 언제나 모든 피처의 전체 영역으로 간주되지 선택된 피처들만으로 계산된"
" 영역으로 간주되지는 않는다는 뜻입니다. 우리 모델에 추가 도구 몇 개를 사용해서 이 문제를 해결해보도록 하겠습니다."

#: ../../docs/training_manual/processing/modeler_only.rst:10
msgid ""
"Open the modeler and start the model by adding the required inputs. In this "
"case we need a vector layer (restricted to points) and an attribute from it,"
" with the values that we will use for rasterizing."
msgstr ""
"모델 설계자를 열고 필수 입력물을 추가해서 모델을 실행하십시오. 이 경우 (포인트만으로 제한된) 벡터 레이어 하나와, 래스터화 작업에 "
"사용할 값들을 가진 해당 레이어의 속성이 필요합니다."

#: ../../docs/training_manual/processing/modeler_only.rst:14
msgid ""
"The next step is to compute the extent of the selected features. That's "
"where we can use the model-only tool called *Vector layer bounds*. First, we"
" will have to create a layer that has the extent of those selected features."
" Then, we can use this tool on that layer."
msgstr ""
"그 다음 선택된 피처들의 영역을 계산해야 합니다. 이때 :guilabel:`Vector layer bounds` 라는 모델 전용 도구를 "
"사용할 수 있습니다. 먼저 해당 선택 피처들의 영역을 가진 레이어를 생성해야 합니다. 그 다음 이 레이어에 도구를 사용하면 됩니다."

#: ../../docs/training_manual/processing/modeler_only.rst:16
msgid ""
"An easy way of creating a layer with the extent of the selected features is "
"to compute a convex hull of the input points layer. It will use only the "
"selected point, so the convex hull will have the same bounding box as the "
"selection. Then we can add the *Vector layer bounds* algorithm, and use the "
"convex hull layer as input. It should look this in the modeler canvas:"
msgstr ""
"입력 포인트 레이어의 볼록 껍질을 계산하면 선택 피처들의 영역을 가진 레이어를 쉽게 생성할 수 있습니다. 이 과정에서 선택된 포인트들만 "
"사용하기 때문에 볼록 껍질과 선택 집합의 경계 상자는 동일할 것입니다. 그 다음 볼록 껍질을 입력 받는 :guilabel:`Vector "
"layer bounds` 알고리즘을 추가하면 됩니다. 모델 설계자 캔버스에서 다음과 같이 보일 것입니다:"

#: ../../docs/training_manual/processing/modeler_only.rst:20
msgid ""
"The result from the *Vector layer bounds* is a set of four numeric values "
"and a extent object. We will use both the numeric outputs and the extent for"
" this exercise."
msgstr ""
":guilabel:`Vector layer bounds` 가 산출하는 결과물은 숫자값 4개를 가진 집합과 영역 피처 하나입니다. 이 "
"예제에서는 숫자값 산출물과 영역 둘 다 사용할 것입니다."

#: ../../docs/training_manual/processing/modeler_only.rst:24
msgid ""
"We can now add the algorithm that rasterizes the vector layer, using the "
"extent from the *Vector layer bounds* algorithm as input."
msgstr ""
"이제 :guilabel:`Vector layer bounds` 알고리즘의 산출물을 입력 받아 벡터 레이어를 래스터화하는 알고리즘을 추가할"
" 수 있습니다."

#: ../../docs/training_manual/processing/modeler_only.rst:26
msgid "Fill the parameters of the algorithm as shown next:"
msgstr "이 알고리즘의 파라미터를 다음과 같이 채워 넣으십시오:"

#: ../../docs/training_manual/processing/modeler_only.rst:30
msgid "The canvas should now look like."
msgstr "이제 캔버스가 다음과 같이 보일 것입니다:"

#: ../../docs/training_manual/processing/modeler_only.rst:34
msgid ""
"Finally, fill the no-data values of the raster layer using the *Close gaps* "
"algorithm."
msgstr "마지막으로 :guilabel:`Close gaps` 알고리즘을 사용해서 래스터 레이어의 NODATA 값을 채우십시오."

#: ../../docs/training_manual/processing/modeler_only.rst:38
msgid ""
"The algorithm is now ready to be saved and added to the toolbox. You can run"
" it and it will generate a raster layer from interpolating the selected "
"points in the input layer, and the layer will have the same extent as the "
"selection."
msgstr ""
"이제 알고리즘을 저장하고 툴박스에 추가할 준비가 끝났습니다. 이 알고리즘을 실행하면 입력 레이어에서 선택된 포인트들을 보간한 래스터 "
"레이어를 생성할 것입니다. 이 산출 레이어는 입력된 선택 집합과 동일한 영역을 가지고 있을 겁니다."

#: ../../docs/training_manual/processing/modeler_only.rst:40
msgid ""
"Here's an improvement to the algorithm. We have used a harcoded value for "
"the cellsize when rasterizing. This value is fine for our test input layer, "
"but might not be for other cases. We could add a new parameter, so the user "
"enters the desired value, but a much better approach would be to have that "
"value automatically computed."
msgstr ""
"이제 이 알고리즘을 향상시켜 봅시다. 우리는 방금 예제에서 래스터화 도중 셀 크기 값을 직접 입력했습니다. 이 값은 이번 입력 레이어에 "
"대해서는 괜찮았지만, 다른 경우에도 괜찮을 거란 보장은 없습니다. 사용자가 새 파라미터를 추가해서 적당한 값을 직접 입력해도 되지만, 이"
" 값을 자동적으로 계산하게 하는 것이 더 나은 방법이겠죠."

#: ../../docs/training_manual/processing/modeler_only.rst:42
msgid ""
"We can use the modeler-only calculator, and compute that value from the "
"extent coordinates. For instance, to create a layer with a fixed width of "
"100 pixels, we can use the following formula in the calculator."
msgstr ""
"모델 설계자 전용 계산기를 사용해서 영역 좌표로부터 이 값을 계산하면 됩니다. 예를 들면 계산기에 다음과 같은 공식을 사용하면 레이어를 "
"고정 너비 100픽셀로 생성할 수 있습니다."

#: ../../docs/training_manual/processing/modeler_only.rst:46
msgid ""
"Now we have to edit the rasterize algorithm, so it uses the output of the "
"calculator instead of the hardcoded value."
msgstr "이제 직접 입력한 값이 아니라 계산기가 산출한 값을 사용하도록 래스터화 알고리즘을 편집해야 합니다."

#: ../../docs/training_manual/processing/modeler_only.rst:48
msgid "The final algorithm should look like this:"
msgstr "최종 알고리즘은 다음처럼 보일 것입니다:"
