# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2002-now, QGIS project
# This file is distributed under the same license as the QGIS Documentation
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
# 
# Translators:
# Harrissou Sant-anna, 2024
# Kwon.Yongchan <ruvyn@naver.com>, 2024
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: QGIS Documentation 3.34\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-09-15 11:22+0000\n"
"PO-Revision-Date: 2024-03-02 11:57+0000\n"
"Last-Translator: Kwon.Yongchan <ruvyn@naver.com>, 2024\n"
"Language-Team: Korean (https://app.transifex.com/qgis/teams/6144/ko/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../<rst_prolog>:5
msgid ""
"Translation is a community effort :ref:`you can join "
"<translation_guidelines>`. This page is currently translated at |translation"
" progress|."
msgstr ""
"번역은 :ref:`여러분이 참여할 수 있는 <translation_guidelines>` 커뮤니티 활동입니다. 이 페이지는 현재 "
"|translation progress| 번역되었습니다."

#: ../../docs/user_manual/processing/console.rst:4
msgid "Using processing algorithms from the console"
msgstr "콘솔에서 공간 처리 알고리즘 사용"

#: ../../docs/user_manual/processing/console.rst:11
msgid ""
"The console allows advanced users to increase their productivity and perform"
" complex operations that cannot be performed using any of the other GUI "
"elements of the processing framework. Models involving several algorithms "
"can be defined using the command-line interface, and additional operations "
"such as loops and conditional sentences can be added to create more flexible"
" and powerful workflows."
msgstr ""
"고급 사용자는 콘솔을 통해 생산성을 향상시키는 것은 물론, 공간 처리 프레임워크의 다른 모든 GUI 항목을 통해서도 수행할 수 없는 "
"복잡한 작업을 수행할 수 있습니다. 명령 줄 인터페이스를 사용해서 여러 알고리즘을 연결한 모델을 정의하고, 더욱 유연하고 강력한 작업 "
"흐름을 생성하기 위한 반복문(``for``) 및 조건문(``if``)과 같은 부가적인 작업을 추가할 수 있습니다."

#: ../../docs/user_manual/processing/console.rst:18
msgid ""
"There is not a processing console in QGIS, but all processing commands are "
"available instead from the QGIS built-in :ref:`Python console <console>`.  "
"That means that you can incorporate those commands into your console work "
"and connect processing algorithms to all the other features (including "
"methods from the QGIS API) available from there."
msgstr ""
"QGIS는 공간 처리 콘솔을 내장하고 있지 않지만, 그 대신 QGIS에 내장된 :ref:`파이썬 콘솔 <console>` 에서 모든 공간"
" 처리 명령어를 사용할 수 있습니다. 즉 사용자의 콘솔 작업에 공간 처리 명령어를 포함시켜 콘솔에서 사용할 수 있는 다른 (QGIS "
"API가 지원하는 메소드를 포함한) 모든 기능에 공간 처리 알고리즘을 연결할 수 있다는 의미입니다."

#: ../../docs/user_manual/processing/console.rst:24
msgid ""
"The code that you can execute from the Python console, even if it does not "
"call any specific processing method, can be converted into a new algorithm "
"that you can later call from the toolbox, the graphical modeler or any other"
" component, just like you do with any other algorithm. In fact, some "
"algorithms that you can find in the toolbox are simple scripts."
msgstr ""
"사용자가 파이썬 콘솔에서 실행하는 코드는, 비록 어느 특정한 공간 처리 메소드를 호출하지 않더라도, 다른 모든 알고리즘과 마찬가지로 향후"
" 툴박스, 모델 설계자, 또는 기타 구성 요소에서 호출할 수 있는 새 알고리즘으로 변환할 수 있습니다. 사실, 툴박스에서 찾아볼 수 있는"
" 알고리즘 가운데 일부는 단순한 스크립트일 뿐입니다."

#: ../../docs/user_manual/processing/console.rst:31
msgid ""
"In this section, we will see how to use processing algorithms from the QGIS "
"Python console, and also how to write algorithms using Python."
msgstr ""
"이 절에서 QGIS 파이썬 콘솔에서 공간 처리 알고리즘을 사용하는 방법과 함께 파이썬으로 알고리즘을 작성하는 방법에 대해 설명하겠습니다."

#: ../../docs/user_manual/processing/console.rst:35
msgid "Calling algorithms from the Python console"
msgstr "파이썬 콘솔에서 알고리즘 호출하기"

#: ../../docs/user_manual/processing/console.rst:37
msgid ""
"The first thing you have to do is to import the processing functions with "
"the following line:"
msgstr "사용자는 가장 먼저 공간 처리 함수를 다음 명령어로 가져와야 합니다:"

#: ../../docs/user_manual/processing/console.rst:44
msgid ""
"Now, there is basically just one (interesting) thing you can do with that "
"from the console: execute an algorithm. That is done using the :meth:`run() "
"<qgis.core.QgsProcessingAlgorithm.run>` method, which takes the name of the "
"algorithm to execute as its first parameter, and then a variable number of "
"additional parameters depending on the requirements of the algorithm. So the"
" first thing you need to know is the name of the algorithm to execute. That "
"is not the name you see in the toolbox, but rather a unique command–line "
"name. To find the right name for your algorithm, you can use the "
":class:`processingRegistry <qgis.core.QgsProcessingRegistry>`. Type the "
"following line in your console:"
msgstr ""
"이제 사용자가 이 콘솔을 통해 할 수 있는 (흥미로운) 일은 기본적으로 단 하나뿐입니다. 알고리즘을 실행하는 것이죠. "
":meth:`run() <qgis.core.QgsProcessingAlgorithm.run>` 메소드를 사용하면 알고리즘을 실행할 수 "
"있습니다. 첫 번째 파라미터로 실행할 알고리즘명을 그리고 해당 알고리즘의 요구 사항에 따라 다양한 추가 파라미터들을 받아 알고리즘을 "
"실행하는 메소드입니다. 따라서 사용자가 가장 먼저 알아야 할 점은 실행할 알고리즘의 이름입니다. 이 이름은 툴박스에서 찾아볼 수 있는 "
"이름이 아니며, 오히려 유일한 명령 줄 이름에 가깝습니다. 사용자 알고리즘의 정확한 이름을 찾으려면 "
":class:`processingRegistry <qgis.core.QgsProcessingRegistry>` 를 사용하면 됩니다. "
"사용자 콘솔에 다음 명령어를 입력하십시오:"

#: ../../docs/user_manual/processing/console.rst:61
msgid ""
"You will see something like this (with some extra dashes added to improve "
"readability)."
msgstr "다음과 같은 화면을 보게 될 겁니다. (가독성을 향상시키기 위해 점선이 추가될 수도 있습니다.)"

#: ../../docs/user_manual/processing/console.rst:81
msgid ""
"That's a list of all the available algorithm IDs, sorted by provider name "
"and algorithm name, along with their corresponding names."
msgstr ""
"이 목록은 사용 가능한 모든 알고리즘 ID를 제공자명과 알고리즘명으로 정렬하고 대응하는 명령 줄 이름과 함께 정리한 것입니다."

#: ../../docs/user_manual/processing/console.rst:84
msgid ""
"Once you know the command-line name of the algorithm, the next thing to do "
"is to determine the right syntax to execute it. That means knowing which "
"parameters are needed when calling the ``run()`` method."
msgstr ""
"알고리즘의 명령 줄 이름을 찾았다면, 다음은 해당 알고리즘을 실행하기 위한 올바른 문법을 알아내야 합니다. 즉 ``run()`` 메소드 "
"호출 시 어떤 파라미터가 필요한지 알고 있어야 한다는 뜻입니다."

#: ../../docs/user_manual/processing/console.rst:88
msgid ""
"There is a method to describe an algorithm in detail, which can be used to "
"get a list of the parameters that an algorithm requires and the outputs that"
" it will generate. To get this information, you can use the "
"``algorithmHelp(id_of_the_algorithm)`` method. Use the ID of the algorithm, "
"not the full descriptive name."
msgstr ""
"알고리즘이 요구하는 파라미터 목록 및 알고리즘이 생성하는 산출물에 관한 정보를 얻을 수 있도록 알고리즘을 상세히 설명해주는 메소드가 "
"존재합니다. 이런 정보를 얻으려면, ``algorithmHelp(id_of_the_algorithm)`` 메소드를 사용하면 됩니다. "
"알고리즘의 서술적인 전체 이름이 아니라 알고리즘 ID를 사용하십시오."

#: ../../docs/user_manual/processing/console.rst:94
msgid ""
"Calling the method with ``native:buffer`` as parameter (``qgis:buffer`` is "
"an alias for ``native:buffer`` and will also work), you get the following "
"description:"
msgstr ""
"이 메소드를 ``native:buffer`` 파라미터와 (``qgis:buffer`` 는 ``native:buffer`` 의 별명으로, "
"똑같이 작동할 것입니다) 함께 호출하면, 다음과 같은 설명을 보게 됩니다:"

#: ../../docs/user_manual/processing/console.rst:222
msgid ""
"Now you have everything you need to run any algorithm. As we have already "
"mentioned, algorithms can be run using: ``run()``. Its syntax is as follows:"
msgstr ""
"이제 알고리즘을 실행하기 위해 필요한 모든 내용을 알았습니다. 앞에서 언급했듯이, 알고리즘을 실행할 수 있는 명령어는 ``run()`` "
"입니다. 그 문법은 다음과 같습니다:"

#: ../../docs/user_manual/processing/console.rst:230
msgid ""
"Where parameters is a dictionary of parameters that depend on the algorithm "
"you want to run, and is exactly the list that the ``algorithmHelp()`` method"
" gives you."
msgstr ""
"'parameters' 는 사용자가 실행하려는 알고리즘에 따라 달라지는 파라미터 목록인데, ``algorithmHelp()`` 메소드가 "
"제공하는 목록과 정확히 일치합니다."

#: ../../docs/user_manual/processing/console.rst:247
msgid ""
"If a parameter is optional and you do not want to use it, then don't include"
" it in the dictionary."
msgstr "써도 되고 안 써도 되는 파라미터인데 사용하고 싶지 않은 경우, 목록에 포함시키지 마십시오."

#: ../../docs/user_manual/processing/console.rst:250
msgid "If a parameter is not specified, the default value will be used."
msgstr "파라미터를 지정하지 않는 경우, 기본값을 사용할 것입니다."

#: ../../docs/user_manual/processing/console.rst:252
msgid ""
"Depending on the type of parameter, values are introduced differently. The "
"next list gives a quick review of how to introduce values for each type of "
"input parameter:"
msgstr ""
"파라미터의 유형에 따라, 값을 서로 다르게 입력해야 합니다. 다음은 각 입력 파라미터 유형 별로 값을 입력하는 방법을 간단하게 설명하는 "
"목록입니다:"

#: ../../docs/user_manual/processing/console.rst:255
msgid ""
"Raster Layer, Vector Layer or Table. Simply use a string with the name that "
"identifies the data object to use (the name it has in the QGIS Table of "
"Contents) or a filename (if the corresponding layer is not opened, it will "
"be opened but not added to the map canvas). If you have an instance of a "
"QGIS object representing the layer, you can also pass it as parameter."
msgstr ""
"래스터 레이어, 벡터 레이어, 또는 테이블: 그냥 사용할 데이터 객체를 식별하는 이름(QGIS 범례에 표시되는 이름) 또는 파일명(해당 "
"레이어가 열려 있지 않은 경우, 레이어를 열지만 맵 캔버스에는 추가하지 않습니다)을 나타내는 문자열을 입력하십시오. 레이어를 나타내는 "
"QGIS 객체 인스턴스가 있을 경우, 해당 인스턴스도 파라미터로 넘겨줄 수 있습니다."

#: ../../docs/user_manual/processing/console.rst:260
msgid ""
"Enumeration. If an algorithm has an enumeration parameter, the value of that"
" parameter should be entered using an integer value. To know the available "
"options, you can use the ``algorithmHelp()`` command, as above. For "
"instance, the ``native:buffer`` algorithm has an enumeration called "
"JOIN_STYLE:"
msgstr ""
"집합(enumeration): 알고리즘이 집합 파라미터를 받을 경우, 해당 파라미터의 값을 정수 값으로 입력해야 합니다. 사용할 수 있는"
" 옵션을 알고 싶다면, 앞의 예시에서처럼 ``algorithmHelp()`` 명령어를 사용하면 됩니다. 예를 들어 "
"``native:buffer`` 알고리즘은 JOIN_STYLE이라는 집합을 받습니다:"

#: ../../docs/user_manual/processing/console.rst:281
msgid ""
"In this case, the parameter has three options. Notice that ordering is zero-"
"based."
msgstr "이 경우, 옵션 3개 가운데 하나를 이 파라미터로 입력할 수 있습니다. 순서가 0부터 시작한다는 점을 기억하십시오."

#: ../../docs/user_manual/processing/console.rst:283
msgid "Boolean.  Use ``True`` or ``False``."
msgstr "불(boolean): ``True`` 또는 ``False`` 를 사용하십시오."

#: ../../docs/user_manual/processing/console.rst:284
msgid ""
"Multiple input. The value is a string with input descriptors separated by "
"semicolons (``;``). As in the case of single layers or tables, each input "
"descriptor can be the data object name, or its file path."
msgstr ""
"다중 입력: 쌍반점(``;``)으로 구분된 입력 서술자(descriptor)를 나타내는 문자열을 입력하십시오. 단일 레이어 또는 테이블의"
" 경우, 데이터 객체의 이름 또는 파일 경로를 각 입력 서술자로 사용할 수 있습니다."

#: ../../docs/user_manual/processing/console.rst:287
msgid ""
"Table Field from XXX. Use a string with the name of the field to use. This "
"parameter is case-sensitive."
msgstr "XXX 테이블의 필드: 사용할 필드의 이름을 나타내는 문자열을 입력하십시오. 이 파라미터는 대소문자를 구별합니다."

#: ../../docs/user_manual/processing/console.rst:289
msgid ""
"Fixed Table. Type the list of all table values separated by commas (``,``) "
"and enclosed between quotes (``\"``). Values start on the upper row and go "
"from left to right. You can also use a 2-D array of values representing the "
"table."
msgstr ""
"고정 테이블: 큰따옴표(``\"``)로 감싸고 쉼표(``,``)로 구분한 모든 테이블 값의 목록을 입력하십시오. 이때 값은 상단 행부터 "
"왼쪽에서 오른쪽 방향으로 입력합니다. 또는 테이블을 나타내는 값의 2차원 배열을 사용할 수도 있습니다."

#: ../../docs/user_manual/processing/console.rst:292
msgid "CRS. Enter the EPSG code number of the desired CRS."
msgstr "CRS: 원하는 좌표계의 EPGS 코드 번호를 입력하십시오."

#: ../../docs/user_manual/processing/console.rst:293
msgid ""
"Extent. You must use a string with ``xmin``, ``xmax``, ``ymin`` and ``ymax``"
" values separated by commas (``,``)."
msgstr ""
"범위(extent): ``xmin``, ``xmax``, ``ymin`` 및 ``ymax`` 값을 나타내는 쉼표(``,``)로 구분한 "
"문자열을 입력해야 합니다."

#: ../../docs/user_manual/processing/console.rst:296
msgid ""
"Boolean, file, string and numerical parameters do not need any additional "
"explanations."
msgstr "불(boolean), 파일, 문자열 및 숫자 파라미터에 대해서는 따로 설명이 필요없습니다."

#: ../../docs/user_manual/processing/console.rst:299
msgid ""
"Input parameters such as strings, booleans, or numerical values have default"
" values. The default value is used if the corresponding parameter entry is "
"missing."
msgstr ""
"문자열, 불, 또는 숫자 값과 같은 입력 파라미터에는 기본값이 있습니다. 해당 파라미터 항목이 빠져 있을 경우 기본값을 사용합니다."

#: ../../docs/user_manual/processing/console.rst:302
msgid ""
"For output data objects, type the file path to be used to save it, just as "
"it is done from the toolbox. If the output object is not specified, the "
"result is saved to a temporary file (or skipped if it is an optional "
"output). The extension of the file determines the file format. If you enter "
"a file extension not supported by the algorithm, the default file format for"
" that output type will be used, and its corresponding extension appended to "
"the given file path."
msgstr ""
"산출 데이터 객체의 경우, 툴박스에서와 마찬가지로 산출물을 저장하기 위한 파일 경로를 입력하십시오. 산출물 객체를 지정하지 않을 경우 "
"산출물을 임시 파일로 저장합니다. (또는 부가적인 산출물일 경우 건너뜁니다.) 파일의 확장자가 파일 포맷을 결정합니다. 알고리즘이 "
"지원하지 않는 파일 확장자를 입력할 경우 해당 산출물 유형의 기본 파일 포맷을 사용하며, 입력한 파일 경로 끝에 해당 확장자를 덧붙일 "
"것입니다."

#: ../../docs/user_manual/processing/console.rst:310
msgid ""
"Unlike when an algorithm is executed from the toolbox, outputs are not added"
" to the map canvas if you execute that same algorithm from the Python "
"console using the :meth:`run() <qgis.core.QgsProcessingAlgorithm.run>` "
"method. That method returns a dictionary with one or more output names (the "
"ones shown in the algorithm description) as keys and the file paths of those"
" outputs as values:"
msgstr ""
"툴박스에서 알고리즘을 실행할 때와는 달리, 파이썬 콘솔에서 :meth:`run() "
"<qgis.core.QgsProcessingAlgorithm.run>` 메소드를 사용해서 동일한 알고리즘을 실행해도 산출물이 QGIS 맵"
" 캔버스에 추가되지 않습니다. 이 메소드는 (알고리즘 설명에 보이는) 하나 이상의 산출물 이름을 가진 딕셔너리를 키로 그리고 이 "
"산출물들의 파일 경로를 값으로 반환합니다:"

#: ../../docs/user_manual/processing/console.rst:331
msgid "You can then load the output in the project as any common layer:"
msgstr "그러면 프로젝트에 산출물을 다음과 같이 다른 모든 레이어처럼 불러올 수 있습니다:"

#: ../../docs/user_manual/processing/console.rst:339
msgid ""
"To immediately load the processing outputs in the project, you can use the "
"``runAndLoadResults()`` method instead of ``run()``."
msgstr ""
"프로젝트에 공간 처리 산출물을 즉시 불러오려면, ``run()`` 대신 ``runAndLoadResults()`` 메소드를 사용하면 "
"됩니다."

#: ../../docs/user_manual/processing/console.rst:348
msgid ""
"If you want to open an algorithm dialog from the console you can use the "
"``createAlgorithmDialog`` method. The only mandatory parameter is the "
"algorithm name, but you can also define the dictionary of parameters so that"
" the dialog will be filled automatically:"
msgstr ""
"콘솔에서 알고리즘 대화창을 열고 싶다면 ``createAlgorithmDialog`` 메소드를 사용하면 됩니다. 필수적인 파라미터는 "
"알고리즘명 하나뿐이지만, 파라미터 목록도 정의해서 대화창의 파라미터를 자동으로 채울 수도 있습니다:"

#: ../../docs/user_manual/processing/console.rst:367
msgid "The ``execAlgorithmDialog`` method opens the dialog immediately:"
msgstr "``execAlgorithmDialog`` 메소드는 대화창을 즉시 엽니다:"

#: ../../docs/user_manual/processing/console.rst:384
msgid "Creating scripts and running them from the toolbox"
msgstr "스크립트 생성 및 툴박스에서 실행"

#: ../../docs/user_manual/processing/console.rst:386
msgid ""
"You can create your own algorithms by writing Python code. Processing "
"scripts extend :class:`QgsProcessingAlgorithm "
"<qgis.core.QgsProcessingAlgorithm>`, so you need to add some extra lines of "
"code to implement mandatory functions. You can find :guilabel:`Create new "
"script` (clean sheet) and :guilabel:`Create New Script from Template` "
"(template that includes code for mandatory functions of "
":class:`QgsProcessingAlgorithm <qgis.core.QgsProcessingAlgorithm>`) under "
"the :guilabel:`Scripts` dropdown menu on the top of the Processing toolbox. "
"The Processing Script Editor will open, and that's where you should type "
"your code. Saving the script from there in the :file:`scripts` folder (the "
"default folder when you open the save file dialog) with a :file:`.py` "
"extension should create the corresponding algorithm."
msgstr ""
"파이썬 코드를 작성하면 사용자 고유의 알고리즘을 생성할 수 있습니다. 공간 처리 스크립트는 "
":class:`QgsProcessingAlgorithm <qgis.core.QgsProcessingAlgorithm>` 클래스를 확장하기"
" 때문에, 필수 함수를 구현하는 코드를 몇 줄 추가해야 합니다. 공간 처리 툴박스 상단의 :guilabel:`Scripts` 드롭다운 "
"메뉴에 :guilabel:`Create new script` (백지 상태) 및 :guilabel:`Create New Script "
"from Template` (:class:`QgsProcessingAlgorithm "
"<qgis.core.QgsProcessingAlgorithm>` 클래스의 필수 함수를 위한 코드를 포함하는 템플릿) 메뉴가 있습니다. "
"공간 처리 스크립트 편집기가 열리면 사용자의 코드를 입력해야 합니다. 이 편집기에서 :file:`scripts` 폴더(파일 저장 대화창의"
" 기본 폴더)에 스크립트를 :file:`.py` 확장자를 붙여 저장하면 대응하는 알고리즘을 생성할 것입니다."

#: ../../docs/user_manual/processing/console.rst:401
msgid ""
"The name of the algorithm (the one you will see in the toolbox) is defined "
"within the code."
msgstr "사용자의 코드 안에서 알고리즘의 (툴박스에 표시될) 이름을 정의합니다."

#: ../../docs/user_manual/processing/console.rst:404
msgid ""
"Let's have a look at the following code, which defines a Processing "
"algorithm that performs a buffer operation with a user defined buffer "
"distance on a vector layer that is specified by the user, after first "
"smoothing the layer."
msgstr ""
"다음 코드를 한번 살펴봅시다. 이 코드는 먼저 레이어를 평탄화한 다음, 사용자가 지정한 벡터 레이어 상에 사용자 정의 버퍼 거리로 버퍼 "
"작업을 수행하는 공간 처리 알고리즘을 정의합니다:"

#: ../../docs/user_manual/processing/console.rst:469
msgid ""
"After doing the necessary imports, the following "
":class:`QgsProcessingAlgorithm <qgis.core.QgsProcessingAlgorithm>` functions"
" are specified:"
msgstr ""
"필요한 클래스들을 가져온 다음, 다음과 같은 :class:`QgsProcessingAlgorithm "
"<qgis.core.QgsProcessingAlgorithm>` 함수들을 지정합니다:"

#: ../../docs/user_manual/processing/console.rst:473
msgid ""
":meth:`name() <qgis.core.QgsProcessingAlgorithm.name>`: The id of the "
"algorithm (lowercase)."
msgstr ":meth:`name() <qgis.core.QgsProcessingAlgorithm.name>`: 알고리즘 ID (소문자)"

#: ../../docs/user_manual/processing/console.rst:475
msgid ""
":meth:`displayName() <qgis.core.QgsProcessingAlgorithm.displayName>`: A "
"human readable name for the algorithm."
msgstr ""
":meth:`displayName() <qgis.core.QgsProcessingAlgorithm.displayName>`: 사람이 읽을"
" 수 있는 알고리즘 이름"

#: ../../docs/user_manual/processing/console.rst:477
msgid ""
":meth:`createInstance() <qgis.core.QgsProcessingAlgorithm.createInstance>`: "
"Create a new instance of the algorithm class."
msgstr ""
":meth:`createInstance() <qgis.core.QgsProcessingAlgorithm.createInstance>`: "
"알고리즘 클래스용 새 인스턴스 생성"

#: ../../docs/user_manual/processing/console.rst:479
msgid ""
":meth:`initAlgorithm() <qgis.core.QgsProcessingAlgorithm.initAlgorithm>`: "
"Configure the parameterDefinitions and outputDefinitions."
msgstr ""
":meth:`initAlgorithm() <qgis.core.QgsProcessingAlgorithm.initAlgorithm>`: "
"'parameterDefinitions' 및 'outputDefinitions' 환경 설정"

#: ../../docs/user_manual/processing/console.rst:482
msgid ""
"Here you describe the parameters and output of the algorithm.  In this case,"
" a feature source for the input, a feature sink for the result and a number "
"for the buffer distance."
msgstr ""
"여기에 알고리즘의 파라미터와 산출물을 설명합니다. 이 경우, 입력물용 피처 소스, 산출물용 피처 싱크(sink), 그리고 버퍼 거리용 "
"숫자 값이 되겠군요."

#: ../../docs/user_manual/processing/console.rst:485
msgid ""
":meth:`processAlgorithm() "
"<qgis.core.QgsProcessingAlgorithm.processAlgorithm>`: Do the work."
msgstr ""
":meth:`processAlgorithm() "
"<qgis.core.QgsProcessingAlgorithm.processAlgorithm>`: 작업 실행"

#: ../../docs/user_manual/processing/console.rst:488
msgid ""
"Here we first run the ``smoothgeometry`` algorithm to smooth the geometry, "
"and then we run the ``buffer`` algorithm on the smoothed output. To be able "
"to run algorithms from within another algorithm we have to set the "
"``is_child_algorithm`` argument to :const:`True`. You can see how input and "
"output parameters are used as parameters to the ``smoothgeometry`` and "
"``buffer`` algorithms."
msgstr ""
"먼저 도형을 평탄화시키기 위해 ``smoothgeometry`` 알고리즘을 실행한 다음, 평탄화된 산출물에 ``buffer`` 알고리즘을"
" 실행합니다. 어떤 알고리즘 내부에서 다른 알고리즘을 실행시키려면 ``is_child_algorithm`` 인자를 "
":const:`True` 로 설정해야 합니다. 입력 및 산출 파라미터를 어떻게 ``smoothgeometry`` 및 ``buffer`` "
"알고리즘에 파라미터로 사용하는지 볼 수 있을 겁니다."

#: ../../docs/user_manual/processing/console.rst:496
msgid ""
"There are a number of different parameter types available for input and "
"output. You can find the full list at :ref:`processing_algs_input_output`."
msgstr ""
"입력물과 산출물로 사용할 수 있는 서로 다른 파라미터 유형이 많이 있습니다. "
":ref:`processing_algs_input_output` 에서 전체 목록을 찾아볼 수 있습니다."

#: ../../docs/user_manual/processing/console.rst:499
msgid ""
"The first parameter to the constructors is the name of the parameter, and "
"the second is the description of the parameter (for the user interface). The"
" rest of the constructor parameters are parameter type specific."
msgstr ""
"구성자(constructor)가 받는 첫 번째 파라미터는 파라미터의 이름이며, 두 번째는 파라미터의 (사용자 인터페이스용) 설명입니다. "
"나머지 구성자 파라미터들은 파라미터 유형에 특화되어 있습니다."

#: ../../docs/user_manual/processing/console.rst:504
msgid ""
"The input can be turned into QGIS classes using the ``parameterAs`` "
"functions of :class:`QgsProcessingAlgorithm "
"<qgis.core.QgsProcessingAlgorithm>`. For instance to get the number provided"
" for the buffer distance as a double::"
msgstr ""
":class:`QgsProcessingAlgorithm <qgis.core.QgsProcessingAlgorithm>` 클래스의 "
"``parameterAs`` 함수를 사용하면 입력물을 QGIS 클래스로 변환할 수 있습니다. 예를 들어 버퍼 거리를 지정하는 숫자를 "
"실수형(double)으로 받으려면:"

#: ../../docs/user_manual/processing/console.rst:510
msgid ""
"The ``processAlgorithm`` function should return a dictionary containing "
"values for every output defined by the algorithm. This allows access to "
"these outputs from other algorithms, including other algorithms contained "
"within the same model."
msgstr ""
"``processAlgorithm`` 함수는 알고리즘이 정의한 모든 산출물에 대한 값을 담고 있는 목록을 반환해야 합니다. 이렇게 해서 "
"동일 모델 안에 있는 다른 알고리즘을 포함한 다른 알고리즘이 이 산출물들에 접근할 수 있게 됩니다."

#: ../../docs/user_manual/processing/console.rst:515
msgid ""
"Well behaved algorithms should define and return as many outputs as makes "
"sense. Non-feature outputs, such as numbers and strings, are very useful "
"when running your algorithm as part of a larger model, as these values can "
"be used as input parameters for subsequent algorithms within the model. "
"Consider adding numeric outputs for things like the number of features "
"processed, the number of invalid features encountered, the number of "
"features output, etc. The more outputs you return, the more useful your "
"algorithm becomes!"
msgstr ""
"제대로 동작하는 알고리즘은 의미가 통하는만큼의 산출물을 정의하고 반환해야 합니다. 숫자 및 문자열 같은 피처가 아닌 산출물은 사용자 "
"알고리즘을 더 큰 모델의 일부로 실행하는 경우 아주 유용합니다. 그 값을 모델 내부의 바로 다음 알고리즘의 입력 파라미터로 사용할 수 "
"있기 때문입니다. 공간 처리된 피처의 개수, 실행중 찾아낸 무결하지 않은 피처의 개수, 피처 산출물의 개수 등과 같은 값을 위해 숫자형 "
"산출물을 추가하는 것도 좋겠죠. 반환되는 산출물이 많을수록, 사용자 알고리즘도 더 유용해지니까요!"

#: ../../docs/user_manual/processing/console.rst:525
msgid "Feedback"
msgstr "피드백"

#: ../../docs/user_manual/processing/console.rst:527
msgid ""
"The :class:`feedback <qgis.core.QgsProcessingFeedback>` object passed to "
":meth:`processAlgorithm() "
"<qgis.core.QgsProcessingAlgorithm.processAlgorithm>` should be used for user"
" feedback / interaction. You can use the :meth:`setProgress() "
"<qgis.core.QgsFeedback.setProgress>` function of the :class:`feedback "
"<qgis.core.QgsProcessingFeedback>` object to update the progress bar (0 to "
"100) to inform the user about the progress of the algorithm. This is very "
"useful if your algorithm takes a long time to complete."
msgstr ""
":meth:`processAlgorithm() "
"<qgis.core.QgsProcessingAlgorithm.processAlgorithm>` 메소드에 넘겨지는 "
":class:`feedback() <qgis.core.QgsProcessingFeedback>` 객체는 사용자 피드백/대화형 작업에 "
"사용되어야 합니다. :class:`feedback() <qgis.core.QgsProcessingFeedback>` 객체의 "
":meth:`setProgress() <qgis.core.QgsFeedback.setProgress>` 함수를 사용하면 알고리즘의 "
"진행도를 알려주는 진행 과정 막대를 (0에서 100 사이의 값으로) 업데이트할 수 있습니다. 사용자 알고리즘이 완료까지 오래 걸리는 경우"
" 매우 유용한 함수입니다."

#: ../../docs/user_manual/processing/console.rst:535
msgid ""
"The :class:`feedback <qgis.core.QgsProcessingFeedback>` object provides an "
":meth:`isCanceled() <qgis.core.QgsFeedback.isCanceled>` method that should "
"be monitored to enable cancelation of the algorithm by the user. The "
":meth:`pushInfo() <qgis.core.QgsProcessingFeedback.pushInfo>` method of "
":class:`feedback <qgis.core.QgsProcessingFeedback>` can be used to send "
"information to the user, and :meth:`reportError() "
"<qgis.core.QgsProcessingFeedback.reportError>` is handy for pushing non-"
"fatal errors to users."
msgstr ""
":class:`feedback() <qgis.core.QgsProcessingFeedback>` 객체는 사용자가 알고리즘을 취소할 수 "
"있게 하려면 감시해야 하는 :meth:`isCanceled() <qgis.core.QgsFeedback.isCanceled>` 메소드를 "
"제공합니다. :class:`feedback() <qgis.core.QgsProcessingFeedback>` 객체의 "
":meth:`pushInfo() <qgis.core.QgsProcessingFeedback.pushInfo>` 메소드를 사용해서 "
"사용자에게 정보를 전달할 수 있고, :meth:`reportError() "
"<qgis.core.QgsProcessingFeedback.reportError>` 메소드는 사용자에게 심각하지 않은(non-fatal)"
" 오류를 푸시하는 데 편리합니다."

#: ../../docs/user_manual/processing/console.rst:543
msgid ""
"Algorithms should avoid using other forms of providing feedback to users, "
"such as print statements or logging to :class:`QgsMessageLog "
"<qgis.core.QgsMessageLog>`, and should always use the feedback object "
"instead. This allows verbose logging for the algorithm, and is also thread-"
"safe (which is important, given that algorithms are typically run in a "
"background thread)."
msgstr ""
"알고리즘은 가급적 서술을 인쇄하거나 :class:`QgsMessageLog <qgis.core.QgsMessageLog>` 에 로그를 "
"작성하는 등의 다른 형태로 사용자에게 피드백을 제공해서는 안 되며, 대신 언제나 피드백 객체를 사용해야 합니다. 피드백 객체를 사용하면 "
"알고리즘이 장황한 로그 작업을 할 수 있으며, 스레드 편에서도 안전합니다. (알고리즘이 일반적으로 배경 스레드에서 실행된다는 점을 "
"감안하면 아주 중요한 이유죠.)"

#: ../../docs/user_manual/processing/console.rst:552
msgid "Handling errors"
msgstr "오류 처리하기"

#: ../../docs/user_manual/processing/console.rst:554
msgid ""
"If your algorithm encounters an error which prevents it from executing, such"
" as invalid input values or some other condition from which it cannot or "
"should not recover, then you should raise a :class:`QgsProcessingException "
"<qgis.core.QgsProcessingException>`. E.g.::"
msgstr ""
"사용자 알고리즘의 실행을 방해하는 오류가 발생한 경우, 예를 들어 입력값이 무결하지 않거나 다른 조건이 맞지 않아 복구되서는 안 되고 될"
" 수도 없을 때, :class:`QgsProcessingException <qgis.core.QgsProcessingException>`"
" 을 발생시켜야 합니다. 예를 들면:"

#: ../../docs/user_manual/processing/console.rst:563
msgid ""
"Try to avoid raising :class:`QgsProcessingException "
"<qgis.core.QgsProcessingException>` for non-fatal errors (e.g. when a "
"feature has a null geometry), and instead just report these errors via "
"``feedback.reportError()`` and skip the feature. This helps make your "
"algorithm \"model-friendly\", as it avoids halting the execution of an "
"entire algorithm when a non-fatal error is encountered."
msgstr ""
"심각하지 않은 오류인 경우 (예를 들어 피처가 NULL 도형을 가진 경우) :class:`QgsProcessingException "
"<qgis.core.QgsProcessingException>` 을 발생시키지 말고 대신 ``feedback.reportError()``"
" 를 통해 오류를 보고만 한 다음 해당 피처를 건너뛰는 편이 좋습니다. 이렇게 하면 사용자 알고리즘이 \"모델 친화적(model-"
"friendly)\" 이 됩니다. 심각하지 않은 오류인 경우 전체 알고리즘 실행을 정지하지 않기 때문이죠."

#: ../../docs/user_manual/processing/console.rst:573
msgid "Documenting your scripts"
msgstr "사용자 스크립트 문서 작성하기"

#: ../../docs/user_manual/processing/console.rst:575
msgid ""
"As in the case of models, you can create additional documentation for your "
"scripts, to explain what they do and how to use them."
msgstr "모델의 경우와 마찬가지로, 사용자 스크립트를 위해 그 목적 및 사용법을 설명하는 추가 문서를 생성할 수 있습니다."

#: ../../docs/user_manual/processing/console.rst:578
msgid ""
":class:`QgsProcessingAlgorithm <qgis.core.QgsProcessingAlgorithm>` provides "
"the :meth:`helpString() <qgis.core.QgsProcessingAlgorithm.helpString>`, "
":meth:`shortHelpString() <qgis.core.QgsProcessingAlgorithm.shortHelpString>`"
" and :meth:`helpUrl() <qgis.core.QgsProcessingAlgorithm.helpUrl>` functions "
"for that purpose. Specify / override these to provide more help to the user."
msgstr ""
":class:`QgsProcessingAlgorithm() <qgis.core.QgsProcessingAlgorithm>` 이 그 목적을"
" 위해 :meth:`helpString() <qgis.core.QgsProcessingAlgorithm.helpString>`, "
":meth:`shortHelpString() <qgis.core.QgsProcessingAlgorithm.shortHelpString>`"
" 및 :meth:`helpUrl() <qgis.core.QgsProcessingAlgorithm.helpUrl>` 함수를 제공합니다. "
"사용자에게 더 많은 도움말을 제공하려면 이 함수들을 지정하거나 무시하십시오."

#: ../../docs/user_manual/processing/console.rst:584
msgid ""
":meth:`shortDescription() "
"<qgis.core.QgsProcessingAlgorithm.shortDescription>` is used in the tooltip "
"when hovering over the algorithm in the toolbox."
msgstr ""
"툴박스에 있는 알고리즘 위로 커서를 가져다대면 나타나는 툴팁에는 :meth:`shortDescription() "
"<qgis.core.QgsProcessingAlgorithm.shortDescription>` 을 사용합니다."

#: ../../docs/user_manual/processing/console.rst:588
msgid "Pre- and post-execution script hooks"
msgstr "실행전 및 실행후 스크립트 후크"

#: ../../docs/user_manual/processing/console.rst:590
msgid ""
"Scripts can also be used as pre- and post-execution hooks that are run "
"before and after an algorithm is run, respectively. This can be used to "
"automate tasks that should be performed whenever an algorithm is executed."
msgstr ""
"스크립트를 알고리즘을 실행하기 전, 실행한 후에 실행되는 실행 전(pre-execution) 및 실행 후(post-execution) "
"후크(hook)로 사용할 수도 있습니다. 후크는 알고리즘을 실행할 때마다 수행해야 하는 작업을 자동화하기 위해 사용됩니다."

#: ../../docs/user_manual/processing/console.rst:594
msgid ""
"The syntax is identical to the syntax explained above, but an additional "
"global variable named ``alg`` is available, representing the algorithm that "
"has just been (or is about to be) executed."
msgstr ""
"후크의 문법은 앞에서 설명한 문법과 동일하지만, ``alg`` 라는 또다른 전체 수준 변수를 사용할 수 있습니다. ``alg`` 는 방금"
" 실행된 (또는 곧 실행될) 알고리즘을 나타내는 변수입니다."

#: ../../docs/user_manual/processing/console.rst:598
msgid ""
"In the :guilabel:`General` group of the processing options dialog, you will "
"find two entries named :guilabel:`Pre-execution script` and :guilabel:`Post-"
"execution script` where the filenames of the scripts to be run in each case "
"can be entered."
msgstr ""
"공간 처리 옵션 대화창의 :guilabel:`General` 그룹에서 :guilabel:`Pre-execution script` 및 "
":guilabel:`Post-execution script` 라는 두 옵션을 볼 수 있는데, 이 두 옵션에 각각의 경우 실행될 스크립트의"
" 파일명을 입력할 수 있습니다."
